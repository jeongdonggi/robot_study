# 픽셀 처리

1.단일 픽셀 처리

이웃 픽셀과는 독립적으로 입력 영상의 각 픽셀 값을 변환한 후 결과 영상의 동일한 위치에 출력하는 연산

종류: 산술 연산(밝기), 논리 연산(추출), Grayscale, 이진화(고정 임계값: 임계값 보다 작으면 0 크면 255)

2.픽셀 그룹 처리

출력 영상의 새로운 픽셀 값을 결정하기 위해 해당 픽셀 뿐만 아니라 그 주위의 이웃 픽셀들도 함께 고려하는 공간 영역 연산(컨볼루션 연산)

종류: 블러링 & 샤프닝, 지역 이진화(가변 임계값)

# 컨볼루션 연산

처리하고자 하는 픽셀 값을 이웃 픽셀의 각각에 대응하는 2차원 배열 내의 가중치를 곱하고 그 값을 모두 더한 값으로 변경하는 연산

필터(Filter, Mask): 입력되는 신호의 일부 성분을 제거하거나 일부 특성을 변경하기 위해 셜계된 시스템

함수: cv2.filter2D(입력 영상, 출력 영상의 데이터 타입, 필터 행렬)

# 이진화

어떤 주어진 임계값보다 큰 픽셀은 흰색으로 작은 픽셀은 검은 색으로 바꾸는 작업

1.전역 이진화 (고정 임계값, 잘 안 쓰임)

각 픽셀 값이 임계값보다 작으면 0 크면 255로 픽셀 값 변경

단점: 밝기 변화가 심한 영상에는 임계값 설정이 어려움

함수: cv2.threshold(입력 영상, 임계값, 임계값보다 클 때 적용되는 값, 임계값 적용 방법)

2.지역 이진화 (가변 임계값)

픽셀 그룹 단위마다 임계값을 설정하고 그 값보다 작으면 0 크면 255로 픽셀 값 변경

함수: cv2.adaptiveThreshold(입력 영상, 임계값 보다 클 때 적용되는 최대값, 적용할 지역 이진화 알고리즘, 임계값 적용 방법, 지역 이진화를 할 때 고려할 주변 픽셀 크기, 블록 내 평균 값에서 뺄 값)

# 블러링 & 샤프닝

블러링: 이웃 픽셀들의 차이를 감소시켜 영상을 부드럽게 만드는 기법(noise를 제거하기 위해 쓰임)

필터 적용 함수: cv2.filter2D(입력 영상, 출력 영상의 데이터 타입, 필터 행렬)

필터 종류: 평균 값, 미디언, 가우시안

평균값: 영상의 특정 픽셀과 주변 픽셀들의 산술 평균을 결과 영상 픽셀 값으로 설정하는 필터

가장 간편하게 사용할 수 있고 크기가 커지면 더 흐려짐

미디언: 입력 영상에서 주변 픽셀들의 값들으 오름 또는 내림 차순으로 정렬하여 그 중앙에 있는 값으로 픽셀 값을 대체하는 방식의 필터
- 중간에 있는 값을 평균 값으로 바꿔주는거임

 Salt & Pepper Noise를 효과적으로 제거(점처럼 되는거)

함수: cv2.medianBlur(입력 영상, 필터 크기)

가우시안: 가우시안 분포를 이용한 정규화 필터

필터 내부 가중치의 합으로 나눈다 -> 모든 가우시안 필터의 합은 1

빠른 처리 가능

가우시안 분포: 모든 과학 분야에서 가장 보편적인 정규 분포로 실험 오차 측정 등에 많이 사용

함수: cv2.getGaussianKernel(필터 크기, 가우시안 함수 식 중 시그마 값, 필터 타입: default = float64)

cv2.GaussianBlur(원본 이미지, 필터 크기, 가우시안 함수 식 중 시그마값)

샤프닝: 이웃 픽셀들의 차이를 크게 만들어 영상을 날카롭게 만드는 기법

필터의 가중치 값이 양수고 나머지가 음수로 합이 1이되도록 하거나 음수가 되도록 함
# 코드

1번 코드

- 산술 연산 1: uint8이여서 255 넘으면 255를 뺀값이 나오게 됨 그러므로 넘는값을 255로 고정시켜주기 위해 if else 문으로 조건을 넣어 놓음

- 산술 연산 2: add (함수 사용하면 알아서 cliping 해줌)

- 논리 연산: 마스크 배열은 만들어줌, 원하는 부분을 따와서 1로(흰색) 만들어서 거기에 사진을 넣어줌(* 연산 이용: 0이면 검은색으로 바뀌고 1이면 곱하면 원래 값이 나오기 때문)

2번 코드

- 임계값 적용 방법: cv2.THRESH_BINARY : 픽셀 값이 thresh보다 크면 maxval, 작으면 0으로 할당

- 적용할 지역 이진화 알고리즘: cv2.ADAPTIVE_THRESH_MEAN_C : 주변 영역의 평균값으로 결정
임계값 적용 방법: cv2.THRESH_BINARY : 픽셀 값이 thresh보다 크면 maxval, 작으면 0으로 할당

3번 코드

- 데이터 타입: cv2.CV_8U / cv2.CV_32F / cv2.CV_64F
필터는 정사각형으로 만들면 됨
(np.array([[1/9, 1/9, 1/9],[1/9, 1/9, 1/9],[1/9, 1/9, 1/9]]))  or
(np.array([[1, 1, 1],[1, 1, 1],[1, 1, 1]]))/9
-> 3x3 행렬

# 코드 내부 실습

1번 코드

```python
for y in range(binimg.shape[0]):
    for x in range(binimg.shape[1]):
        if (binimg[y][x] <= threshold):
            binimg[y][x] = 0
        else:
            binimg[y][x] = 255
```

3번 코드

```python
#1번 실습
Blurfilter = np.array([[1, 1, 1, 1, 1],[1, 1, 1, 1, 1],[1, 1, 1, 1, 1],[1, 1, 1, 1, 1],[1, 1, 1, 1, 1]])/25
```

```python
#2번 실습
gauss_filter = np.array([[1, 2, 1], [2, 4, 2], [1, 2, 1]]) /16
```

```python
#3번 실습
sharpfilter = np.array([[-1,-1,-1],[-1,9,-1],[-1,-1,-1]])
```

# 과제

- 픽셀 값을 빼면 미분 근사값이 나온다.
- x 커널은 세로 경계가 나오고 y 커널은 가로 경계가 나온다 -> 픽셀 차를 이용하였기 때문

로버츠, 프리윗, 소벨 커널 적용 해보기

```python
import cv2 as cv
import numpy as np

Path = 'Data/'
Name = 'lenna.tif'
src = Path + Name

color_img = cv.imread(src)
image = cv.imread(src, cv.IMREAD_GRAYSCALE) # 에지 검출을 위해 그레이 스케일로 바꿈

#로버츠: 공식이 간단하여 계산 속도가 빠름, 사선 경계 검출 효과를 높이지만 노이즈에 민감하다는 단점이 있다.
#=====================================================================================
#img = image.copy()
#
# # 1. 로버츠 커널 생성
# gx_kernel = np.array([[1,0], [0,-1]])
# gy_kernel = np.array([[0, 1],[-1,0]])
#
# # 2. 커널 적용, 두개를 구해서 더함
# edge_gx = cv.filter2D(img, -1, gx_kernel)
# edge_gy = cv.filter2D(img, -1, gy_kernel)
# edge = edge_gy + edge_gx
#
# # 3. 결과 출력
# # merged = np.hstack((img, edge_gx, edge_gy, edge_gx+edge_gy)) # hstack 배열 가로 결합, vstack 배열 세로 결합
# cv.imshow('roberts', edge)
# cv.waitKey(0)
# cv.destroyAllWindows()
#=====================================================================================

#프리윗: 소벨보다 간단하여 속도가 빠르지만 로버츠보다 더 좋은 에지를 검출 할 수 있음, x축과 y축의 각 방향으로 차분을 세 번 계산 하여 경계를 검출하는 필터, 상하/좌우는 뚜렷하게 검출하지만 대각선 검출에 약함
#=====================================================================================
#img = image.copy()
#
# # 1. 프리윗 커널 생성
# gx_k = np.array([[-1,0,1], [-1,0,1],[-1,0,1]])
# gy_k = np.array([[-1,-1,-1],[0,0,0], [1,1,1]])
# 
# # 2. 프리윗 커널 필터 적용
# edge_gx = cv.filter2D(img, -1, gx_k)
# edge_gy = cv.filter2D(img, -1, gy_k)
# edge = edge_gy + edge_gx
# 
# # 3. 결과 출력
# cv.imshow('prewitt', edge)
# cv.waitKey(0)
# cv.destroyAllWindows()
#=====================================================================================

#소벨: 매우 뚜렷한 에지 검출, 중심 픽셀의 차분 비중을 두배로 준 필터라 다방면으로 강함(가우시안 처럼 가운데 값이 높다)
# 소벨 필터 함수: cv2.Sobel(입력 영상, 출력 영상의 데이터 타입, 미분 차수, 커널 크기, 미분에 사용할 계수, 연산 결과에 가산할 값)
# 미분 크기는 0,1,2 중 선택, 커널 크기는 1,3,5,7 중 선택
#=====================================================================================
#img = image.copy()
#
# # 1. 소벨 커널 생성
# gx_k = np.array([[-1,0,1], [-2,0,2],[-1,0,1]])
# gy_k = np.array([[-1,-2,-1],[0,0,0], [1,2,1]])
# 
# # 2-1. 소벨 필터 적용
# edge_gx = cv.filter2D(img, -1, gx_k)
# edge_gy = cv.filter2D(img, -1, gy_k)
# edge = edge_gy + edge_gx
# 
# # 2-2. 소벨 함수 적용
# sobelx = cv.Sobel(img, -1, 1, 0, ksize=3)
# sobely = cv.Sobel(img, -1, 0, 1, ksize=3)
# sobel = sobely + sobelx
# # 3. 결과 출력
# merged = np.hstack((edge, sobel))
# cv.imshow("sobel", merged)
# cv.waitKey(0)
# cv.destroyAllWindows()
#=====================================================================================
```