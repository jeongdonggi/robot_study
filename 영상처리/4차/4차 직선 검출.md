# 에지 표현

기존 에지 표현: 미분 사용 ( 에지 화소: 1 비에지 화소: 0)

에지가 (화소, 토막) 처럼 이상하게 나오는 것을 방지하기 위한 방법

- 모니터는 정수로만 표현 (이산적인 환경)

1. 화소의 좌표 순서대로 배열에 저장
- 에지 점을 하나하나 토막(선분)으로 저장

2. 체인 코드(시작점만 좌표로 표현 + 나머진 0~7의 방향코드)
- 에지 토막의 시작점만 넣어주고 나머지는 방향코드로 저장, 공간 소비가 적음

# 선분근사

두꺼운 에지를 얇게 만들어주는 방법

에지 검출 - 세션화 - 에지 추적 - 선분 근사

에지 검출(캐니, 프리윗, 로버츠) -> 윤곽선

세선화: 에지의 두께를 1로 만드는 과정(그룹 접근: 마스크 연산) -> 두께 1인 윤곽선

에지 추적: 에지 토막을 검출하는 과정(에지추적) -> 에지 토막

선분 근사 -> 선분

선분 근사 방법:

1. 양 끝점을 연결한 직선으로부터 에지 토막의 가장 먼 점 까지의 거리 계산

2. 거리가 임계값보다 크면 가장 먼 점을 중심으로 두 토막으로 분할

3. 여러번 적용

-> 곡선이 직선으로 표현 가능하게 바뀜

# 허프변환

연결 관계가 명확하지 않거나 잡음으로 인해 작은 조각으로 끊어져 있는 경우가 많음 -> 허프변환: 연결 과정 없이 바로 직선 검출(전역 연산: 저체 공간 조사)

허프 변환

1. 하나의 점에서 그을 수 있는 선분은 무한하다. -> y = ax + b

2. 실제로 수많은 윤각 선 위의 점에서 어떤 것을 연결해야 되는지 확실하지 않음

3. 점들 중에 가장 많이 지나가는 직선을 구한다? 너무 오래 걸린다.

4. x, y 좌표를 a, b 공간으로 바꾼다. -> 무한 개의 선분이 하나의 선분으로 바뀐다.
- y = ax + b -> b = -xa + y 로 바뀌면 하나의 선분으로 바뀜

5. 점 하나 당 a,b 좌표에서 하나의 선분이 그어짐
- 이 말은 선분의 교점을 구하면 된다. -> 계산 횟수가 줄어든다.

6. x,y 공간에서는 a,b의 범위가 무한하지만 영상에서는 범위가 존재 한다. -> 극좌표계 사용(범위를 제한할 수 있음)

7. 극 좌표계에서의 직선의 방정식: r = x*cos + y*sin

8. 극 좌표계로 교점을 찾으면 대부분 정해진 범위 내 에서 찾을 수 있음

# 코드

```python
# 1. 가우시안 블러
    gray_img = cv.cvtColor(frame, cv.COLOR_BGR2GRAY)
    gaussian = cv.GaussianBlur(gray_img, (0, 0), 1)

# 2. 캐니 추출
    canny = cv.Canny(gaussian, 17, 20, 3)

# 3. ROI 추출
    point = np.array([[400, 200], [600, 200], [1000, 500], [0, 500]])
    ROI = region_of_interest(canny, [point])

# 4. 허프 변환
    lines = cv.HoughLines(ROI, 1, np.pi / 180, 270) # 이미지, r값의 범위 (0~1), Theta값의 범위(0~180), 임계치

    if lines is not None: # 현재 프레임에서 직선이 검출 되었을 때
        for i in range(0, len(lines)):
            r = lines[i][0][0] # 검출된 부분 R
            theta = lines[i][0][1] # 검출된 부분 Theta

            # 극좌표계 직선의 방정식 계산
            a = math.cos(theta)
            b = math.sin(theta)
            x0 = a * r
            y0 = b * r

            # 직선을 그릴 기준 점 2개 좌표 계산 (화면 밖 범위의 점으로 하는 것)
            # 직선 방정식으로 그리기 위한 시작점, 끝점 계산
            pt1 = (int(x0 + 2000 * (-b)), (int(y0 + 2000 * a)))  # 2000은 임시 R: 길이를 최대로 해줌
            pt2 = (int(x0 - 2000 * (-b)), (int(y0 - 2000 * a)))
            cv.line(frame, pt1, pt2, (255, 0, 0), 2, cv.LINE_AA)
```